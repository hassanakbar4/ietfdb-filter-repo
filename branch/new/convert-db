#!/usr/bin/python
# -*- python -*-

"""
NAME
	%(program)s - <short description>

SYNOPSIS
	%(program)s [OPTIONS] 

DESCRIPTION
        <long description>

%(options)s

FILES
        The program expects to read two files as input, one giving all information
        about a draft in the format '<draftname> <attr1>="value1"  <attr2>="value2" ...'
        or '<date> <draftname> <attr1>="value1"  <attr2>="value2" ...', the other
        being an aliases file which contain WG chair aliases.  If a file
        argument is given on the command line, it is assumed to be the all-IDs
        state file.  A chair-aliases file must be specified with the
        --chair-aliases option; if none is given, chair aliases will not be generated.

AUTHOR
	Written by Henrik Levkowetz, <henrik@levkowetz.com>

COPYRIGHT
	Copyright 2009 Henrik Levkowetz

	This program is free software; you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation; either version 2 of the License, or (at
	your option) any later version. There is NO WARRANTY; not even the
	implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
	PURPOSE. See the GNU General Public License for more details.

"""

import sys, os.path, getopt, re, traceback

version = "v0.20"
program = os.path.basename(sys.argv[0])
progdir = os.path.dirname(sys.argv[0])

options = ""
for line in re.findall("\n +(if|elif) +opt in \[(.+)\]:\s+#(.+)\n", open(sys.argv[0]).read()):
    if not options:
        options += "OPTIONS\n"
    options += "        %-16s %s\n" % (line[1].replace('"', ''), line[2])
options = options.strip()

# with ' < 1:' on the next line, this is a no-op:
if len(sys.argv) < 1:
    print __doc__ % locals()
    sys.exit(1)

try:
    opts, files = getopt.gnu_getopt(sys.argv[1:], "hvc", ["help", "version",])
except Exception, e:
    print "%s: %s" % (program, e)
    sys.exit(1)

# ----------------------------------------------------------------------

sys.path = [ progdir ] + sys.path
os.environ["DJANGO_SETTINGS_MODULE"] = "ietf.settings"

from datetime import datetime as Datetime

from django.conf import settings

from ietf.idtracker.models import InternetDraft as OldInternetDraft
from ietf.idtracker.models import IDInternal as OldIdInternal
from ietf.idtracker.models import RfcObsolete as OldRfcObsolete
from ietf.idtracker.models import PersonOrOrgInfo as OldPerson
from ietf.utils.draft import Draft, getdraft

from redesign.doc.models import *
from redesign.name.models import *
from redesign.person.models import *

import attrib

# ------------------------------------------------------------------------------
# Function definitions.
# ------------------------------------------------------------------------------
def changes(old, new):
    if not type(old) == type({}):
        old = old.__dict__.copy()
    if not type(new) == type({}):
        new = new.__dict__.copy()
    changed = []
    for key in old:
        if not key.startswith("_"):
            if key in new and old[key] != new[key]:
                changed += [key]
    return changed
        
def get_or_create(Cls, unique, **kwargs):
    try:
        unique = dict( [ (key, kwargs[key]) for key in unique ] )
        obj = Cls.objects.get(**unique)
    except Cls.DoesNotExist:
        try:
            obj, created = Cls.objects.get_or_create(**kwargs)
            if created:
                try:
                    print "Created %s:" % obj._meta.object_name, obj.id, obj.encode("Latin-1")
                except AttributeError:
                    print repr(obj)[:80]
            else:
                changes = changed(obj, kwargs)
                if changed:
                    print "Changed fields:"
                    for key in changes:
                        print "    %s: %s -> " % (key, getattr(obj, key), kwargs[key])
        except Exception, e:
            print Cls.__name__, kwargs
            print e
            raise
    except AssertionError:
        objects = Cls.objects.filter(**unique)
        for obj in list(objects)[1:]:
            print "Deleting duplicate object:", obj
            obj.delete()
        obj = Cls.objects.get(**unique)
        raise
    return obj
    
def get(Cls, **kwargs):
    try:
        obj = Cls.objects.get(**kwargs)
    except Cls.DoesNotExist:
        print "Can't find %s: %s" % (Cls.__name__, kwargs)
        raise
    return obj
    
def get_or_create_person(id=None, date=None, prefix="", first="", middle="", last="", suffix="", addr=""):
    for parts in [
        [ prefix, first, middle, last, suffix, ],
        [ first, middle, last, suffix ],
        [ first, middle, last ],
        [ first, last, suffix ],
        [ first, last ],
        ]:
        parts = [ item for item in parts if item ]         
        name = " ".join(parts)
        person_list = list(set([ alias.person for alias in Alias.objects.filter(name=name) ]))
        if len(person_list) == 0:
            continue
        elif len(person_list) == 1:
            return person_list[0]
        else:
            for item in person_list:
                print "Match:", item.id, item
                item.delete()
            raise Exception("Multiple matching author names")
    name = " ".join([ item for item in [ first, middle, last, suffix, ] if item ])
    person = get_or_create(Person, ["id", ],
        id      = id,
        time    = date or Datetime.now(),
        name    = name,
        ascii   = name,
        address = addr)
    get_or_create(Alias, ["name", "person", ], name=name, person=person)
    if name in auth_alias:
        for alias in auth_alias[name]:
            get_or_create(Alias, ["name", "person", ], name=alias, person=person)
    return person

def get_or_create_person_from_old(p):
    person_list = Person.objects.filter(id=p.person_or_org_tag)
    if person_list.count() == 1:
        return person_list.get(id=p.person_or_org_tag)
    else:
        return get_or_create_person(id=p.person_or_org_tag, date=p.date_modified, prefix=p.name_prefix, first=p.first_name, middle=p.middle_initial, last=p.last_name, suffix=p.name_suffix, addr="Mark 1")

def get_or_create_person_from_name(name):
    prefix, first, middle, last, suffix = parse_name(name)
    return get_or_create_person(prefix=prefix, first=first, middle=middle, last=last, suffix=suffix, addr="Mark 3")

def get_or_create_email(email, person):
    email = get_or_create(Email, ["address"],
        time = Datetime.now(),
        address = email,
        person = person)
    return email

def fix_alias(orig, aliases):
    if orig in aliases.keys():
        return aliases[orig]
    else:
        return orig

def parse_name(name):
    p = Person(name=name, ascii=name)
    return p.name_parts()    

# ------------------------------------------------------------------------------
def listdir(path, pattern):
    dirlist = os.listdir(path)
    files = [ x for x in dirlist if re.match(pattern, x) ]
    files.sort()
    return files

# ------------------------------------------------------------------------------
std_status_aliases = {
    "Best Current Practice": "BCP",
    "Request For Comments":  "Unknown",
    "Request":  "Unknown",
}

#
